#### 线程介绍

**概念**

一个进程可以包含多个线程，统一程序中的所有数据均会独立地执行相同的程序，并且共享一份全局内存区域，其中包括**初始化数据段，未初始化数据段，以及堆内存段**

每个线程都具有各自的**私有栈**空间，不过当然是在进程的地址空间内部

布局分布如下图

<img src="C:\Users\HP\Desktop\image-20211114211029802.png" alt="image-20211114211029802" style="zoom:67%;" />

同一个进程中的多个线程可以并发执行，在多处理器环境下，多个线程可以同时并行

**线程组**

*id*

在所有的线程组中，所有的线程共享同一个进程ID,同一个进程组ID,并且这两个值永远相同

一个线程组中的所有线程都拥有一个唯一的线程标识符(tid),线程id不仅在线程组中唯一，并且在整个系统中都是唯一的

当启动程序时，产生的进程只有唯一条线程，即该进程本身，被称为**初始线程**或**主线程**

*信号*

仅当线程组中的所有线程都终止之后，其父线程才会收到SIGCHLD信号

*子进程*

如果线程组中的某一个线程调用了exec(),那么新的进程将在首线程中执行，其他所有的线程都会终止，调用exec期间，会将该进程发送给其父进程的终止信号重置为SIGCHLD

如果线程组中的某个线程调用了fork()或者vfork()创建了子进程，那么组中的任何线程都可以使用wait()或者它的xd函数来监控该子进程

- pthread_create

  pthread_create()用来创建一条新的线程

  ```c
  #include<pthread.h>
  int pthread_create(pthread_t *thread, const pthread_attr_t* attr,
  					void *(*start)(void *), void *arg);
  											//成功返回0，失败返回一个正数
  ```

  

  新的线程会通过调用带有参数arg的函数start而开始执行，而调用pthread_create()的线程则会继续从后面的语句开始执行

  参数thread指向pthread_t 类型的缓冲区，在**pthread_create()返回之前**，会在此保存一个该线程的唯一标识(tid)

  参数attr是指向pthread_attr_t对象的指针，该对象指定了新线程的各种属性(可以查阅手册，很多)

- pthread_exit

  pthread_exit可以用来终止线程

  ```c
  #include<pthread.h>
  void pthread_exit(void *retval);
  ```

  retval指定了线程的返回值

  对于一个线程来说，它的终止方式有以下几种:

  1. 函数start执行return语句返回一个指定值
  2. 线程调用pthread_exit()
  3. 线程调用pthread_cancle()
  4. 任意一个线程调用exit()(或_exit()),或者在主线程上执行了return语句

- pthread_self

  一个线程可以通过pthread_self()来获取自己的线程ID

  ```c
  #include<pthread.h>
  pthread_t pthread_self(void);
  																//返回调用线程的线程id
  ```

- pthread_equal

  函数equal可以检查两个线程的id是否相同

  ```c
  #include<pthread.h>
  int pthread_equal(pthread_t t1, pthread_t t2);
  															//如果t1==t2则返回非0值，否则返回0
  ```

  之所以使用这个api而不是使用=是因为pthread_t可能是一个结构类型，这个与系统实现有关

- pthread_join

  函数pthread_join()等待由thread表示的线程终止

  ```c
  #include<pthread.h>
  int pthread_join(pthread_t thread, void **retval);
  									//成功返回0,失败则返回一个正值
  ```

  当使用pthread_join()来等待某个线程终止时，这种操作被称为**连接(joining)**

  retval为一非空指针，会保存进程终止时的返回值的拷贝

  ==如果向pthread_join()传入一个之前已然连接过的进程ID,那么可能会导致无法预知的行为==

  如果未能够与线程进行连接，那么将会产生**僵尸线程**，与僵尸进程相似，也会占用系统资源

  ==注:pthread_join()对线程进行等待时，是处于阻塞状态==

- pthread_detach

  默认情况下，一个线程应该是处于**可连接状态(joinbale)**,也就是说，当线程退出时，其他线程可以通过调用pthread_join获取其返回状态

  可如果对一个进程使用pthread_detach()系统调用，那么他就会进入**分离(detached)**状态

  ```c
  #include<pthread.h>
  int pthread_detach(pthread_t thread);
  											//成功返回0,失败返回一个正值
  ```

  但一个线程处于分离状态时，它无法被其他线程回收，只能够自己终止，但是它终止时系统将能够为它自动的进行清理，这就省去了调用pthread_join()的麻烦

  无论线程调用了exit(),或是主线程执行return语句，即便时处于分离状态的线程还是立即终止

