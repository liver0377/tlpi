#### 进程的创建(fork)

fork:创建一个新进程(child),几近于对调用进程(parent)的翻版

```c
#include<unistd.h>
pid_t fork(void)
```

当完成对fork的调用之后，将会存在两个进程，即一个子进程一个父进程，每个进程都会从fork()的返回处继续执行

- 进程间地址空间的关系

  父进程与子进程将执行相同的程序文本段，但却拥有不同的栈段，数据段，以及堆段拷贝   (采用写时复制技术时另说)

  子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制

  执行fork时，每个进程均可以独立的修改各自的栈数据以及堆段中的变量，进程之间互不影响

- 返回值

  父进程的返回值子进程的pid,子进程的返回值是0，通常采用如下的代码来区分父进程与子进程

  ```
  pid_t childPid;
  
  switch(childPid = fork()){
  case -1:   (fork() 失败)
  //错误处理
  //...
  case 0:		(子进程返回)
  //子进程动作
  //...
  default:     (父进程返回)
  //父进程动作
  //...
  }
  ```

  失败时会返回-1

- 进程调度

  当使用fork之后，父子进程的调度顺序是无法确定的，可以采取某些同步技术使得父子进程以特定顺序执行

  - 使用同步信号

    调用fork之后，如果进程甲需要等待进程乙完成某一项工作，那么进程乙可以在动作完成之后向进程甲发送信号，而家只需要在接收到信号之前保持等待(wait)即可

- 父子进程之间的文件共享

  执行fork时，子进程会获得父进程所有文件描述符的副本，那么，**父子进程对应的描述符就会指向相同的打开文件句柄(open file description)**

  由于打开文件句柄中包含着文件的各种属性，包括文件偏移量，状态标志，访问模式等，那么**这些属性将会在父子进程之间共享**

  如果想规避这种特性，就需要注意以下两点:

  - 令父子进程使用不同的文件描述符
  - 各自立即关闭不再使用的文件描述符

  <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211111154012818.png" alt="image-20211111154012818" style="zoom:80%;" />

- fork的内存语义

  早期的UNIX实现中，父进程会将内存拷贝至交换空间，以此创建新的内存映像，然后将该映像置为子进程，但是这样有一个缺点:太浪费空间，特别是在fork之后立即使用exec()的情况，因为使用exec()会对子进程的地址空间进行重新初始化，相当于白复制了

  UNIX实现采用两种技术来避免这种浪费

  - 代码段

    系统在调用fork()为子进程创建代码段时，其所构建的一系列进程级的页表项，即页表条目，均**指向与父进程相同的物理内存页帧**

  - 数据段、堆栈段

    内核采用**写时复制(copy-on-write)**技术，刚调用fork时，子进程的页表项与父进程指向相同的物理页帧，当需要对父进程或子进程的页面进行修改时，内核就会为这些修改的页面创建拷贝，值得注意的是，这些拷贝都是给子进程使用的，父进程永远使用原来的物理页帧

    <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211111155342085.png" alt="image-20211111155342085" style="zoom:80%;" />

