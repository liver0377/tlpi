#### 进程的创建(fork)

fork:创建一个新进程(child),几近于对调用进程(parent)的翻版

```c
#include<unistd.h>
pid_t fork(void)
```

当完成对fork的调用之后，将会存在两个进程，即一个子进程一个父进程，每个进程都会从fork()的返回处继续执行

- 进程间地址空间的关系

  父进程与子进程将执行相同的程序文本段，但却拥有不同的栈段，数据段，以及堆段拷贝   (采用写时复制技术时另说)

  子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制

  执行fork时，每个进程均可以独立的修改各自的栈数据以及堆段中的变量，进程之间互不影响

- 返回值

  父进程的返回值子进程的pid,子进程的返回值是0，通常采用如下的代码来区分父进程与子进程

  ```
  pid_t childPid;
  
  switch(childPid = fork()){
  case -1:   (fork() 失败)
  //错误处理
  //...
  case 0:		(子进程返回)
  //子进程动作
  //...
  default:     (父进程返回)
  //父进程动作
  //...
  }
  ```

  失败时会返回-1

- 进程调度

  当使用fork之后，父子进程的调度顺序是无法确定的，可以采取某些同步技术使得父子进程以特定顺序执行

  - 使用同步信号

    调用fork之后，如果进程甲需要等待进程乙完成某一项工作，那么进程乙可以在动作完成之后向进程甲发送信号，而家只需要在接收到信号之前保持等待(wait)即可

- 父子进程之间的文件共享

  执行fork时，子进程会获得父进程所有文件描述符的副本，那么，**父子进程对应的描述符就会指向相同的打开文件句柄(open file description)**

  由于打开文件句柄中包含着文件的各种属性，包括文件偏移量，状态标志，访问模式等，那么**这些属性将会在父子进程之间共享**

  如果想规避这种特性，就需要注意以下两点:

  - 令父子进程使用不同的文件描述符
  - 各自立即关闭不再使用的文件描述符

  <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211111154012818.png" alt="image-20211111154012818" style="zoom:80%;" />

- fork的内存语义

  早期的UNIX实现中，父进程会将内存拷贝至交换空间，以此创建新的内存映像，然后将该映像置为子进程，但是这样有一个缺点:太浪费空间，特别是在fork之后立即使用exec()的情况，因为使用exec()会对子进程的地址空间进行重新初始化，相当于白复制了

  UNIX实现采用两种技术来避免这种浪费

  - 代码段

    系统在调用fork()为子进程创建代码段时，其所构建的一系列进程级的页表项，即页表条目，均**指向与父进程相同的物理内存页帧**

  - 数据段、堆栈段

    内核采用**写时复制(copy-on-write)**技术，刚调用fork时，子进程的页表项与父进程指向相同的物理页帧，当需要对父进程或子进程的页面进行修改时，内核就会为这些修改的页面创建拷贝，值得注意的是，这些拷贝都是给子进程使用的，父进程永远使用原来的物理页帧

    <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211111155342085.png" alt="image-20211111155342085" style="zoom:80%;" />



#### 进程的终止

- _exit()

  通常进程有两种终止方式，一种是**异常终止**，当进程接受到某一个信号，而该信号的默认动作又是终止当前进程(term | core)时，进程就会被异常终止

  此外，进程可以使用_exit()系统调用来**正常终止**

  ```C
  #include<unistd.h>
  void _exit(int status);	
  									//return 0 表示正常退出，非0表示异常退出
  ```

  参数status定义了进程的**终止状态**,父进程可以使用`wait`来获取该状态

  status虽然为int类型，但是只有低8位会被父进程使用,还可以返回常量:EXIT_SUCCESS,EXIT_FAILURE来表示返回的状态

  >虽然status的取值范围为0~255(2^8 - 1),但是最好不要使用128以上的返回值，因为当使用信号来终止进程时，shell会将变量$?(上一个命令的返回结果，0表示没有错误)置为128 + 信号值，可能会与返回值相等，造成冲突

- exit()

  exit是标准C语言函数库，其对_exit()进行了封装

  ```c
  #include<stdlib.h>
  void exit(int status)
  									//return 0表示正常退出，非0表示异常退出
  ```

  使用exit时会执行的动作如下:

  - 调用退出处理程序(看下文)
  - 刷新stdio缓冲区
  - 执行_exit(status)

  顺便介绍一下return 关键字,当程序使用return关键字或者在void函数中执行到程序末尾时，会隐式地执行exit(),

  return  n ------->exit(n), 没有指定返回值的话的话就是exit(0)(也不一定,C99这样规定，但是C89未做定义)

- 退出处理程序

  **退出处理程序**是一个由程序设计者提供的函数，可与进程声明周期的任意时点**注册**,并且会在进程调用exit()时自动调用

  如果程序直接调用_exit()或者是因为信号而导致异常终止，那么信号处理程序便不会执行

  可以采用建立信号处理程序，在信号处理程序中设置标志位，进而在主程序中使用退出处理程序，来弥补一些限制

  **注册退出处理程序**

  - atexit()


  ```c
  #include<stdlib.h>
  int atexit(void (*func)(void))
  											//return 0 成功，非0失败
  ```

  atexit会将func添加到一个函数列表，进程终止时会调用该函数列表中的所有函数、

  1. **当注册多个退出处理程序时，这些函数的执行顺醋与注册顺序相反**

  2. 在调用某一个退出处理程序时，如果调用发生异常导致该函数无法返回，那么剩余的所有处  理函数均不会执行

  3. 通过fork调用创建的子进程会继承附近产注册的退出处理函数(复制文本段)

     通过exec调用会移除所有已经注册的退出处理程序(初始化所有段)

  - on_exit()

    这是一个glibc非标准函数,但是功能更加强大

    ```c
    #define _DEFAULT_SOURCE
    #include<stdlib.h>
    int on_exit(void(*func)(int, void*), void* arg)
    											//return 0 成功，非0失败
    ```

    func函数中的int参数为调用exit(status)时给定的status参数，void*类型参数为注册时(即使用on_exit(func, arg)),用户自己给定的参数arg，用于在退出处理程序实现一些自定义功能

- fork(), stdio缓冲区，以及_exit()之间的交互

  由于stdio缓冲区是在进程的**用户空间**进行维护的，所以使用fork时就会理所当然的将其拷贝到子进程的用户空间，在父子进程调用exit()会刷新各自的stdio缓冲区，由此可能就会导致重复的输出结果

  如何避免?

  - 可以在调用fork()之前使用函数fflush()来手动刷新缓冲区，当然也可以使用setvbuf或者setbuf来关闭缓冲功能
  - 子进程使用_exit()终止而不是exit(),这样就不会刷新exit()缓冲区

  



