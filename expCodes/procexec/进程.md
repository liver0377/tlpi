#### 进程的创建(fork)

fork:创建一个新进程(child),几近于对调用进程(parent)的翻版

```c
#include<unistd.h>
pid_t fork(void)
```

当完成对fork的调用之后，将会存在两个进程，即一个子进程一个父进程，每个进程都会从fork()的返回处继续执行

- 进程间地址空间的关系

  父进程与子进程将执行相同的程序文本段，但却拥有不同的栈段，数据段，以及堆段拷贝   (采用写时复制技术时另说)

  子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制

  执行fork时，每个进程均可以独立的修改各自的栈数据以及堆段中的变量，进程之间互不影响

- 返回值

  父进程的返回值子进程的pid,子进程的返回值是0，通常采用如下的代码来区分父进程与子进程

  ```
  pid_t childPid;
  
  switch(childPid = fork()){
  case -1:   (fork() 失败)
  //错误处理
  //...
  case 0:		(子进程返回)
  //子进程动作
  //...
  default:     (父进程返回)
  //父进程动作
  //...
  }
  ```

  失败时会返回-1

- 进程调度

  当使用fork之后，父子进程的调度顺序是无法确定的，可以采取某些同步技术使得父子进程以特定顺序执行

  - 使用同步信号

    调用fork之后，如果进程甲需要等待进程乙完成某一项工作，那么进程乙可以在动作完成之后向进程甲发送信号，而家只需要在接收到信号之前保持等待(wait)即可

- 父子进程之间的文件共享

  执行fork时，子进程会获得父进程所有文件描述符的副本，那么，**父子进程对应的描述符就会指向相同的打开文件句柄(open file description)**

  由于打开文件句柄中包含着文件的各种属性，包括文件偏移量，状态标志，访问模式等，那么**这些属性将会在父子进程之间共享**

  如果想规避这种特性，就需要注意以下两点:

  - 令父子进程使用不同的文件描述符
  - 各自立即关闭不再使用的文件描述符

  <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211111154012818.png" alt="image-20211111154012818" style="zoom:80%;" />

- fork的内存语义

  早期的UNIX实现中，父进程会将内存拷贝至交换空间，以此创建新的内存映像，然后将该映像置为子进程，但是这样有一个缺点:太浪费空间，特别是在fork之后立即使用exec()的情况，因为使用exec()会对子进程的地址空间进行重新初始化，相当于白复制了

  UNIX实现采用两种技术来避免这种浪费

  - 代码段

    系统在调用fork()为子进程创建代码段时，其所构建的一系列进程级的页表项，即页表条目，均**指向与父进程相同的物理内存页帧**

  - 数据段、堆栈段

    内核采用**写时复制(copy-on-write)**技术，刚调用fork时，子进程的页表项与父进程指向相同的物理页帧，当需要对父进程或子进程的页面进行修改时，内核就会为这些修改的页面创建拷贝，值得注意的是，这些拷贝都是给子进程使用的，父进程永远使用原来的物理页帧

    <img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211111155342085.png" alt="image-20211111155342085" style="zoom:80%;" />



#### 进程的终止(_exit)

- _exit()

  通常进程有两种终止方式，一种是**异常终止**，当进程接受到某一个信号，而该信号的默认动作又是终止当前进程(term | core)时，进程就会被异常终止

  此外，进程可以使用_exit()系统调用来**正常终止**

  ```C
  #include<unistd.h>
  void _exit(int status);	
  									//return 0 表示正常退出，非0表示异常退出
  ```

  参数status定义了进程的**终止状态**,父进程可以使用`wait`来获取该状态

  status虽然为int类型，但是只有低8位会被父进程使用,还可以返回常量:EXIT_SUCCESS,EXIT_FAILURE来表示返回的状态

  >虽然status的取值范围为0~255(2^8 - 1),但是最好不要使用128以上的返回值，因为当使用信号来终止进程时，shell会将变量$?(上一个命令的返回结果，0表示没有错误)置为128 + 信号值，可能会与返回值相等，造成冲突

- exit()

  exit是标准C语言函数库，其对_exit()进行了封装

  ```c
  #include<stdlib.h>
  void exit(int status)
  									//return 0表示正常退出，非0表示异常退出
  ```

  使用exit时会执行的动作如下:

  - 调用退出处理程序(看下文)
  - 刷新stdio缓冲区
  - 执行_exit(status)

  顺便介绍一下return 关键字,当程序使用return关键字或者在void函数中执行到程序末尾时，会隐式地执行exit(),

  return  n ------->exit(n), 没有指定返回值的话的话就是exit(0)(也不一定,C99这样规定，但是C89未做定义)

- 退出处理程序

  **退出处理程序**是一个由程序设计者提供的函数，可与进程声明周期的任意时点**注册**,并且会在进程调用exit()时自动调用

  如果程序直接调用_exit()或者是因为信号而导致异常终止，那么信号处理程序便不会执行

  可以采用建立信号处理程序，在信号处理程序中设置标志位，进而在主程序中使用退出处理程序，来弥补一些限制

  **注册退出处理程序**

  - atexit()


  ```c
  #include<stdlib.h>
  int atexit(void (*func)(void))
  											//return 0 成功，非0失败
  ```

  atexit会将func添加到一个函数列表，进程终止时会调用该函数列表中的所有函数、

  1. **当注册多个退出处理程序时，这些函数的执行顺醋与注册顺序相反**

  2. 在调用某一个退出处理程序时，如果调用发生异常导致该函数无法返回，那么剩余的所有处  理函数均不会执行

  3. 通过fork调用创建的子进程会继承附近产注册的退出处理函数(复制文本段)

     通过exec调用会移除所有已经注册的退出处理程序(初始化所有段)

  - on_exit()

    这是一个glibc非标准函数,但是功能更加强大

    ```c
    #define _DEFAULT_SOURCE
    #include<stdlib.h>
    int on_exit(void(*func)(int, void*), void* arg)
    											//return 0 成功，非0失败
    ```

    func函数中的int参数为调用exit(status)时给定的status参数，void*类型参数为注册时(即使用on_exit(func, arg)),用户自己给定的参数arg，用于在退出处理程序实现一些自定义功能

- fork(), stdio缓冲区，以及_exit()之间的交互

  由于stdio缓冲区是在进程的**用户空间**进行维护的，所以使用fork时就会理所当然的将其拷贝到子进程的用户空间，在父子进程调用exit()会刷新各自的stdio缓冲区，由此可能就会导致重复的输出结果

  如何避免?

  - 可以在调用fork()之前使用函数fflush()来手动刷新缓冲区，当然也可以使用setvbuf或者setbuf来关闭缓冲功能
  - 子进程使用_exit()终止而不是exit(),这样就不会刷新exit()缓冲区

  



#### 进程的监控(wait...)

- wait

  系统调用wait等来调用进程的任何一个子进程**终止**，同时将该子进程的信息存储在status中

  ```C
  #include<sys/wait.h>
  pid_t wait(int *status)
  											//成功:返回终止的子进程ID 失败:返回-1
  ```

  如果调用之前并没有子进程终止，那么调用将**一直阻塞**，直到某一个子进程终止

  如果调用进程的所有子进程都已经终止了，那么wait将返回-1，并且将errno置为ECHILD

  通常使用如下代码来等待所有子进程退出

  ```C
  while((childPid = wait(NULL)) != -1)
      continue;
  if(errno != ECHILD)
  	errExit("wait");
  ```

- waitpid

  wait系统调用只要当子进程**终止**时才能够获取到子进程的相关信息，而waitpid则可以获取到更多信息

  **进程的状态改变**

  当以下事件发生其一时，我们就说**进程的状态发生改变**

  - 子进程调用_exit()（或exit())终止
  - 子进程收到信号，并且因为该信号的默认行为(core | term)而**终止**
  - 子进程因为信号而**停止**
  - 停止的子进程收到SIGCONT信号而恢复运行

  ```c
  #include<sys/wait.h>
  pip_t waitpid(pid_t pid, int *status, int options)
  													//成功:返回子进程ID或0，失败:返回-1
  ```

  pid参数解释:

  - 如果pid > 0，表示等待进程ID为pid
  - 如果pid = 0,则等待与调用进程位于同一个进程组的所有进程
  - 如果pid < -1,则会等待与pid绝对值相等的所有子进程
  - 如果pid = -1,则会等待所有子进程

  部分options如下:

  1. WUNTRACED

     返回因信号而**停止**的子进程以及终止子进程信息

  2. WCONTINUED

     返回因为收到SIGCONT信号而恢复执行的子进程信息

  3. **WNOHANG**

     采取**轮询方式(polling)**，即不进行阻塞

     如果没有子进程的**状态改变**，那么立即返回0

**从信号处理程序中终止进程**               (感觉没啥用)

值得注意的是，但在信号处理程序中使用_exit()时，调用该函数的进程会终止

如果需要通知父进程自己因为某个信号而终止，那么需要在信号处理程序中做一些操作

```
void handler(int sig){
//做一些工作
signal(sig, SIG_DFL);			//将信号处置设为默认，一般是终止
raise(sig);						//自举，重新进行信号处理函数，此时就会正常终止
}
```

- waitid

  waitid可以进行更为精确的操作

  ```c
  #include<sys/wait.h>
  int waited(idtype_t idtype, id_t id, siginfo_t *info, int option)
  												//错误：返回-1   正常:0  特殊的WNOHANG选项..?
  ```

  - 如果idtype为P_ALL,则等待任何进程，忽略id值
  - 如果idtype为P_PID, 那么等待ID为id为子进程
  - 如果idtype为P_PGID,那么等待进程组ID为id的所有子进程

  option...，查手册吧

**孤儿进程与僵尸进程**

- 孤儿进程

  当一个进程的父进程已经终止，而其自身还未终止，那么进程之祖---init(pid = 1)就会收养该进程

- 僵尸进程

  当一个进程已经终止，而其父进程仍未使用wait/waitpid...等系统调用将,那么该子进程就被称为**僵尸进程**

  当一个子进程被内核转换为僵尸进程时，内核将释放子进程所把持的大部分系统资源，但是在**内核表**中仍为其维护者一项条目，记录这该子进程的pid,终止状态，资源的使用数据等
  大量的僵尸进程将可能填满进程表，阻碍新进程的创建

  **无法使用SIGKILL这种“必杀”信号来杀死僵尸进程，只能等待父进程的终止**，当父进程终止后，init进程会接管这些僵尸进程，然后将他们从内核表中清除

**注:当子进程终止时，系统会向他们的父进程来发送SIGCHILD信号**

